let unit = false in

let pow = λx. λn. 
    let aux = rec f. λp. λacc.
        if (p <= n && n <= p)
        then
            acc
        else 
            f (p + 1) (x * acc)
    in
    aux 0 1
in

let exp = λx.
    let b = 2.71828 in
    pow b x
in

let log = λn. 
    let e = 2.71828 in
    let aux = rec f. λx. λacc. 
        if (x <= e && x + 1 <= e)
        then 
            acc
        else   
            f (x/e) (acc + (1 - 0.71828))
    in
    aux n (0.71828/2)
in

let pair = λx.λy.λp. p x y in
let fst = λp.p (λx.λy.x) in
let snd = λp.p (λx.λy.y) in

let nil = pair true true in
let isnil = fst2 in
let cons = λh.λt. pair false (pair h t) in
let head = λz. fst (snd z) in
let tail = λz. snd (snd z) in

let map = λf. λx.
    let aux = rec g. λx.
        if isnil x 
        then
            nil
        else
            cons (f (head x)) (g (tail x))
    in aux x
in

let length = λx.
	let aux = rec g. λacc. λx.
		if isnil x
		then 
			acc
		else
			g (acc + 1) (tail x)
	in aux 0 x
in

let fold = rec g. λf. λacc. λx.
  if isnil x 
  then
    acc
  else
    g f (f acc (head x)) (tail x)
in

let nSteps = rec f. λn.
    if n <= 0 && 0 <= n
    then 
        unit 
    else 
        let _ = step in 
        f (n - 1)
in


let iteri = λf. λx.
	let aux = rec g. λi. λx.
		if isnil x 
		then 
			nil
		else
            cons (f i (head x)) (g (i + 1) (tail x))
	in
	aux 0 x
in

let sigmoid = λv.
    let sigmoid' = λx. 
        if ~ (x <= 500.0)
        then
            1.0
        else
            (exp x) / (exp x + 1.0)
    in
    map sigmoid' v
in

let pm = rec pm. λn. λm.
    if n <= 0 && 0 <= n 
    then
        nil
    else
        let pv = rec pv. λq.
            if q <= 0 && 0 <= q
            then
                nil
            else
                let el = pc 1 in
                cons el (pv (q - 1))
        in
        cons (pv m) (pm (n - 1) m)
in

let dot_product_vectors = λv1. λv2.
    let dot_product' = rec f. λv1'. λv2'. λacc.
        if (isnil v1') || (isnil v2')
        then
            acc
        else    
            let v1h = head v1' in
            let v1tl = tail v1' in
            let v2h = head v2' in
            let v2tl = tail v2' in
            f v1tl v2tl ((v1h * v2h) + acc)
    in
    dot_product' v1 v2 0
in

let dot_product_vector_matrix = λv. λm.
    map (λx. dot_product_vectors v x) m
in

let add_vectors = λv1. λv2.
    map2 (λa. λb. a + b) v1 v2
in

let cross_entropy_loss = λy. λy'.
    let find_max = λv.
        let aux = rec f. λmax. λv'.
            if isnil v'
            then 
                max
            else 
                if max <= (head v') 
                then 
                    f (head v') (tail v')
                else 
                    f max (tail v')
        in
        aux (0 - 1) v    
    in
    let y_hat = find_max y' in
    0 - (y * log y_hat) + ((1 - y) * log (1 - y_hat))  
in

let gradient_descent = rec gradient_descent. λinput. λoutput. λparameters. λloss_function. λdata. λlearning_rate. λepochs. λnum_layers.
    let calculate_loss = λdata.
        let len = length data in
        let calculate_loss' = rec calculate_loss'. λacc. λdata.
            if isnil data 
            then
                acc / len
            else
                let (x , y) = head data in
                let _ = set input to x in
                let _ = nSteps num_layers in 
                let y' = peek output in
                calculate_loss' (acc + loss_function y y') (tail data)
        in
        calculate_loss' 0 data
    in
    let gradient_descent' = rec gradient_descent'. λepochs.
        if epochs <= 0 && 0 <= epochs
        then
            false
        else
            let d = 0.001 in
            let g = λe.
                let old = calculate_loss data in
                let _ = setp parameters to (parameters ⊞ (d ⊠ e)) in
                let new = calculate_loss data in
                ((old - new) / d) ⊠ e
            in
            let updated_parameters = fold (λe. λps. (0 - learning_rate * (g e)) ⊞ ps) parameters in
            let _ = setp parameters to updated_parameters in
            gradient_descent' (epochs - 1)
    in
    gradient_descent' epochs
in

let create_vector_cell = rec f. λsize. λval. 
    if size <= 0 && 0 <= size
    then
        nil
    else
        let el = cell val in
        cons el (f (size - 1) val)
in

let create_vector_cell_t = λel. λpos. λsize. λval.
    let create_vector_cell_t' = rec f. λacc. λsize.
        if size <= 0 && 0 <= size
        then
            nil
        else
            if acc <= pos && pos <= acc
            then
                cons el (f (acc + 1) (size - 1))
            else
                let el' = cell val in
                cons el' f (acc + 1) (size - 1)
    in 
    create_vector_cell_t 0 size
in 

let recurrent_neural_network = λinput_size. λhidden_size. λoutput_size. λloss_function. λdata. λlearning_rate. λepochs.
    let wxh = pm hidden_size input_size in
    let whh = pm hidden_size hidden_size in
    let whz = pm output_size hidden_size in

    let bh = pm hidden_size 1 in 
    let bz = pm output_size 1 in

    let xs = create_vector_cell input_size 0 in

    let y = 
        let prev_h = create_vector_cell input_size 0 in
        let forward_pass = rec forward_pass. λxs. λt. λacc.
            if isnil xs
            then
                acc
            else
                let new_input = create_vector_cell_t (head xs) t input_size in
                let mulx = dot_product_vector_matrix new_input wxh in
                let mulh = dot_product_vector_matrix prev_h whh in
                let addh = add_vectors (add_vectors mulx mulh) bh in
                let next_h = sigmoid addh in
                let mulz = dot_product_vector_matrix next_h whz in
                let addz = add_vectors mulz bz in
                let _ = set prev_h to next_h in
                let _ = nSteps num_layers in
                forward_pass (tail xs) (t + 1) addz
        forward_pass xs 0 0   
    in

    let ps = abs y in

    let num_layers = 1 in

    let _ = gradient_descent x y ps loss_function data learning_rate epochs num_layers in
    let calculate_output =  λinput. λoutput. λnum_layers. λvalue.
        let _ = set input to value in
        let _ = nSteps num_layers in 
        peek y
    in
    calculate_output x y num_layers
in
    
let dataset = cons ((3 , 0 , 1 , 2) , 3) (cons ((4 , 0 , 1 , 2) , 4) nil) in

let input_size = 31 in
let hidden_size = 30 in
let output_size = 2 in

let learning_rate = 0.0001 in
let epochs = 1000 in

let f = recurrent_neural_network input_size hidden_size output_size ci_loss dataset learning_rate epochs in
f